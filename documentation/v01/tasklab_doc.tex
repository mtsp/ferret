\documentclass[a4paper,10pt]{article}

\usepackage{titlesec}

\setcounter{secnumdepth}{4}

\usepackage{fullpage}
\usepackage[british]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{titling}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{wrapfig}

%% inset source code
\usepackage{listings}
\lstset{
  language={C++},
  basicstyle=\fontsize{8}{8}\selectfont\ttfamily
}

%% easylist
\usepackage[ampersand]{easylist}
\ListProperties(Hide=100, Hang=true, Progressive=3ex, Style*=-- ,
Style2*=$\bullet$ ,Style3*=$\circ$ ,Style4*=\tiny$\blacksquare$ )

% information about author and title
\title {
    \normalfont \normalsize
    \huge Tasklab\\ % The assignment title
    \normalfont \normalsize {A task simulation API}\\
    \textsc{v0.1} \\ [8pt]
}
\author{Alexandre Medeiros \and Isadora Sophia}
\date{}

\usepackage{hyperref}
% \hypersetup {
%   bookmarks=true,
%   pdftitle={\thetitle},
%   pdfauthor={\theauthor},
%   hidelinks
% }

\begin{document}
\maketitle

\section{Introduction}
    The tasklab was designed to enable the simulation of task parallelism applications without relying on multiple benchmarks. The API consists in enabling the user:
    \begin{itemize}
        \item Generate, by the user parameters, a directed acyclic graph (DAG) that would represent an arbitrary application with task parallelism;
        \item serialize the generated DAG, allowing it to be reproduced repeatedly;
        \item visualize the simulated application by a \textit{.dot} file;
        \item communicate directly with the runtime in order to execute the generated DAG file;
        \item faster and practical performance analysis.
    \end{itemize}

\section{Tasklab API}
    The following tasklab API describes version 0.1. It consists of three files: \textbf{common.h}, which consists of the graph data and serialization functions; \textbf{gen-dag.h}, implements the DAG generation; \textbf{dispatcher.h}, dispatches the graph to the runtime.

    \subsection{Common.h}
        \begin{lstlisting}
void Graph::save(const Graph &g, const char* filename);
        \end{lstlisting}

        Method responsible for saving a graph as a \textit{.dat} file, by serializing it.
        \vspace{1mm} 

        \begin{easylist}
            & g: graph to be serialized;
            & filename: name of the file.
        \end{easylist}

        \begin{lstlisting}
void Graph::restore(Graph **g, const char* filename);
        \end{lstlisting}

        Method responsible for retrieving a graph stored on a \textit{.dat} file, by deserializing it.
        \vspace{1mm} 

        \begin{easylist}
            & g: where the graph should be restored;
            & filename: name of the serialized graph file.
        \end{easylist}

        \begin{lstlisting}
void Graph::show(const Graph &g, const char* filename);
        \end{lstlisting}

        Method responsible for saving a graph as a \textit{.dot} file, allowing to visualize it.
        \vspace{1mm} 

        \begin{easylist}
            & g: graph to be saved;
            & filename: name of the file.
        \end{easylist}

    \newpage
    \subsection{Gen-dag.h}
        \begin{lstlisting} 
void Gen_dag::generate(Graph** graph, uint n, uint m,
                       uint d = DEFAULT_DEP_RANGE,
                       uint t = DEFAULT_LOAD_TIME,
                       float r = DEFAULT_LOAD_RANGE);
        \end{lstlisting}
        Method responsible for generating the DAG that represents the application with task parallelism to be simulated. Each parameter corresponds as follows:
        \vspace{1mm} 

        \begin{easylist}
            & graph: pointer where the final graph will be stored. It must be freed by the user afterwards;
            & n: number of tasks to be generated;
            & m: maximum number of IN/INOUT dependencies that has to be created on each task;
            & d: how far a predecessor may be from a parent (optional);
            & t: standard load time per task (ms) (optional);
            & r: maximum range from standard load time (from 0 to 1) (optional).
        \end{easylist} 
        \vspace{1mm} 

        All the optional parameters have a default value, which can be defined by the user.

    \vspace{3mm} 

    \subsection{Dispatcher.h}
        \begin{lstlisting} 
void Dispatcher::dispatch(Graph* g);
        \end{lstlisting}

        Method responsible for dispatching a graph to the MTSP runtime, displaying on-the-fly information regarding the tasks and if it succeeded the execution. The success is defined by checking if the graph was executed in the appropriate order.
        \vspace{1mm} 

        \begin{easylist}
            & g: graph to be dispatched.
        \end{easylist}

        \vspace{5mm} 
\section{Useful cases}
    Some cases that can be pointed out as examples in which the tasklab API may be useful:
    \begin{enumerate}
        \item Measure a performance of a given runtime and compare it with another libraries;
        \item Check for correctness in the execution of applications in a given plataform;
        \item Allow multiple benchmarking without relying in real applications.
    \end{enumerate}

\section{The design}
    \subsection{How it works}
       The generation works as follows: first, the graph is created with \textit{n} tasks, specified by the user.

       For each created task: a random load time is assigned according to the \textit{default load time} and its \textit{maximum range} - for example, if the default load time is 1000 ms and the load range is 0.25, it may vary from 750ms to 1250ms; a random number of dependencies is created, ranging from 1 to \textit{maximum}, also specified by the user. 

       Then, each dependency in the task is described as follows: a unique id is assigned, for later on purposes; a predecessor that haven't been picked yet is selected, which its \textit{maximum distance} is defined according to the parameter of dependency range; the predecessor task receives an OUT dependency, with the same id as the successor dependency, relating both tasks; finally, the dependency is assigned as IN or INOUT, randomly.

       The dispatcher works by simply communicating with the runtime, by calling its functions in order to describe each of the graph tasks and execute them. Each task triggers an arbitrary function that simply awaits for the given load time.

    \subsection{Graph format}
       The DAG is saved according to the graph data in \textbf{common.h}. The code below corresponds to the public data of the \textbf{Graph} class:

       \begin{lstlisting}
    std::vector<Task> tasks;        // tasks structure
    uint  total_tasks;              // total number of tasks
    uint  total_deps;               // total number of dependencies between tasks

    uint  dep_range;                // max range of how far a predecessor may be

    uint  load_time;                // describes the standard load time per task (ms)
    float max_range;                // max. range from standard load time (0 to 1) 
       \end{lstlisting}

       Public data of \textbf{Task} class:

       \begin{lstlisting}
    std::list<Dep> predecessors;    // predecessors tasks
    std::list<Dep> successors;      // by default, all successor tasks are OUT

    uint  C_dep_tasks;              // total number of predecessors
    float load;                     // how long should the task remain on load
       \end{lstlisting}

       Finally, public data of \textbf{Dep} class:

       \begin{lstlisting}
    uint task;                      // task that the dependency is heading towards to
    Type type;                      // type of dependency
    uint index;                     // the index of the dependency
       \end{lstlisting}       

       Where \textbf{Type} stands for an enum with values IN, INOUT and OUT.

    \subsection{Graph validation}
        The execution of the graph is validated by creating a boolean list with all the dependencies of the graph based on its unique id, assigned initially to false. 

        It consists of: when a task executes, it assigns all of its successors' dependency as true. Then, if a task executes and all of its predecessors' dependency is defined as true, it means that is safe to execute, i.e. all of its father tasks have already executed; otherwise, the execution is not correct.

        If every task executed correctly, it means that the graph is validated and successfully executed.

\section{Future}
    A 0.2 release of the tasklab application is currently being developed. Some features in development are:

    \begin{itemize}
        \item Allow compatibility with other runtimes;
        \item Enable more customization regarding graph generation.
    \end{itemize}

\end{document}
